vec3 cero = vec3(0), arriba = vec3(0,1,0);
int AA = 2;

float map(in vec3 pos) { 
    return min(pos.y, length(pos - arriba / 2.0) - 0.5); 
}

float map(vec3 rd, float t, vec3 ro) { 
    return map(rd * t + ro); 
}

float calcSoftshadow(in vec3 ro, in vec3 rd, in float mint, in float tmax) {
	float res = 1.0, t = mint; //ro = sup_con aka n 
    
    for(int i = 0; i < 32; i++) {
		if(res >= 1e-4 && t <= tmax) {
            float h = map(rd, t, ro);
            res = min( res, 10.0 / t * h );        
            t += h;
        }               
    }
    
    res = clamp(res, 0.0, 1.0);
    
    return res * res * (-2.0 * res + 3.0);
}

vec3 calcNormal(in vec3 pos) {
    vec2 e = 2.8865e-4 * vec2(1.0,-1.0) ; //2.8865e-4 = dif h    
    /*vec3 a = vec3(2.8865e-4), b = -a * vec3(-1,1,1), c = -a * vec3(1,-1,1), 
        d = -a * vec3(1,1,-1);*/
    vec3 a = e.xxx, b = e.xyy, c = e.yxy, d = e.yyx;
    
    return normalize( a * map( pos + a ) + 
					  b * map( pos + b ) + 
					  c * map( pos + c ) + 
					  d * map( pos + d ) );
}

float castRay( in vec3 ro, in vec3 rd ) {
    float tmin = 1.0, tmax = 20.0,
   
    // bounding volume
        tp1 = -ro.y / rd.y; 
    
    if( tp1 > 0.0 ) tmax = min( tmax, tp1 );
    
    float tp2 = (-ro.y + 1.0) / rd.y; 
    
    if( tp2 > 0.0 ) { 
        if( ro.y > 1.0 ) tmin = max( tmin, tp2 );
        else tmax = min( tmax, tp2 ); 
    }
    
    float t = tmin;
    
    for( int i = 0; i < 64; i++ ) {
	    float precis = 5e-4 * t, res = map(rd, t, ro);
        
        if( res >= precis && t <= tmax ) {        
            t += res;
        }
    }

    if( t>tmax ) t = -1.0;
    
    return t;
}

float calcAO( in vec3 pos, in vec3 nor ) {
	float occ = 0.0, sca = 1.0;
    
    for( int i = 0; i < 5; i++ ) {
        float h = 15.0 / 400.0 * float(i) + 1e-3,
            d = map( h * nor + pos);
        occ += sca * (h - d);
        sca *= 0.95;
    }
    
    return clamp( -1.5 * occ + 1.0, 0.0, 1.0 );    
}

vec3 render( in vec3 ro, in vec3 rd) { 
    vec3  col = cero;
    float t = castRay(ro, rd);

    if( t > -0.5 ) {
        vec3 pos = t * rd + ro, nor = calcNormal( pos ), 
        
        // material        
            mate = vec3(0.3),

        // key light
            lig = normalize( vec3(-0.1, 0.3, 0.6) ), hal = normalize( lig-rd );
        float dif = clamp( dot( nor, lig ), 0.0, 1.0 ) * 
            calcSoftshadow( pos, lig, 0.01, 3.0),
            spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0)* dif *
            (0.04 + 0.96*pow( clamp(1.0+dot(hal,rd),0.0,1.0), 5.0 ));
		        
        // ambient light
        float occ = calcAO( pos, nor ), amb = clamp( nor.y / 2.0 + 0.5, 0.0, 1.0 );
               
        // fog
        col = (mate * 4.0 * dif * vec3(1.0, 0.7, 0.5) + 12.0 * spe * vec3(1.0, 0.70, 0.5) + 
            mate * amb * occ * vec3(0.0, 0.08, 0.1)) * exp( -5e-4 * t * t * t );
    }

	return col;
}

mat3 setCamera( in vec3 ro, in vec3 ta, float cr ) {
	vec3 cw = normalize(ta-ro), cp = vec3(sin(cr), cos(cr),0.0),
        cu = normalize( cross(cw,cp) ), cv = normalize( cross(cu,cw) );
    
    return mat3( cu, cv, cw );
}

void mainImage( out vec4 fragColor, in vec2 fragCoord ) {
    // camera	
    float an = -sin(iTime / 10.0) / 10.0 + 1.2;
    vec3 ro = vec3( cos(an), 1.0 / 3.0, -sin(an) ) * 3.0,
        ta = -4.0 / 10.0 * arriba; 
    // camera-to-world transformation
    mat3 ca = setCamera( ro, ta, 0.0 );
    vec3 tot = cero;

    for( int m=0; m<AA; m++ ) {
        for( int n=0; n<AA; n++ ) {
            // pixel coordinates
            vec2 o = vec2(m, n) / float(AA) - 0.5,
                p = (2.0 * (fragCoord + o) - iResolution.xy) / iResolution.y;

            // ray direction
            vec3 rd = ca * normalize( vec3(p.xy, 2.0) ),

            // render	
                col = render( ro, rd);

            // gamma
            col = pow( col, vec3(0.4545) );

            tot += col;
        }
    }
    
    tot /= float(AA * AA);    
    fragColor = vec4( tot, 1.0 );
}
