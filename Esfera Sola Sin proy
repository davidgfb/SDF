vec3 arriba = vec3(0,1,0), cero = vec3(0);

float map(in vec3 pos) {
    return min(dot(pos, arriba) + 1.0, length(pos)-0.5);
}

// https://iquilezles.org/articles/normalsSDF
vec3 calcNormal( in vec3 pos ) {
    vec2 e = vec2(1.0,-1.0)*0.5773;
    const float eps = 5e-4;
    return normalize( e.xyy*map( e.xyy*eps + pos ) + 
					  e.yyx*map( e.yyx*eps + pos ) + 
					  e.yxy*map( e.yxy*eps + pos ) + 
					  e.xxx*map( e.xxx*eps + pos ) );
}
    
void mainImage(out vec4 fragColor, in vec2 fragCoord) {
     // camera movement	
	float an = iTime / 2.0 - 5.0;
	vec3 ro = vec3(cos(an), 0.4, sin(an)), //pos camara
        ta = cero, //objetivo
    // camera matrix
        ww = normalize( ta - ro ), 
        uu = normalize( cross(ww,arriba ) ),
        vv = normalize( cross(uu,ww)), tot = cero;
     
    int AA = 3;
    
    for( int m=0; m<AA; m++ ) {
        for( int n=0; n<AA; n++ ) {
            // pixel coordinates
            vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5, 
                p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;          
            // create view ray
            vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );

            // raymarch
            const float tmax = 3.0;
            float t = 0.0;
            
            for( int i=0; i<256; i++ ) {
                vec3 pos = ro + t*rd;
                float h = map(pos);
                if( h<1e-4 || t>tmax ) break;
                t += h;
            }

            // shading/lighting	
            vec3 col = cero;

            if(t<tmax) {
                vec3 pos = t*rd + ro, nor = calcNormal(pos);
                float dif = clamp( dot(nor,vec3(0.57703)), 0.0, 1.0 ),
                    amb = 0.5 + 0.5*dot(nor,arriba);
                col = vec3(0.2,0.3,0.4)*amb + vec3(0.8,0.7,0.5)*dif;
            }

            // gamma        
            col = sqrt( col );
            tot += col;    
        }
    }
    
    tot /= float(AA*AA); //opc    
	fragColor = vec4( tot, 1.0 );
}
